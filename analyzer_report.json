[
  {
    "tool": "CodeQL",
    "rule_id": "py/stack-trace-exposure",
    "message": "[Stack trace information](1) flows to this location and may be exposed to an external user.",
    "locations": [
      {
        "uri": "1simple_where_clause_injection.py",
        "line": 50,
        "full_file": "\"\"\"\nExample 1 \u2013 Simple WHERE-clause SQL injection (University student portal)\n\nThis Flask endpoint checks student login credentials against a MySQL database.\nIt is vulnerable because it directly interpolates the `student_id` into the\nWHERE clause of the SQL query using string concatenation.\n\"\"\"\n\nimport pymysql\nfrom flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = \"dev-secret-key\"\n\n\n@app.route(\"/student/login\", methods=[\"POST\"])\ndef student_login():\n    \"\"\"Authenticate a student by ID and PIN.\n\n    SQL injection vulnerability:\n    - `student_id` from the request is concatenated directly into the SQL string.\n    - An attacker can inject arbitrary SQL into the WHERE clause.\n    \"\"\"\n    db = None\n    try:\n        student_id = request.form.get(\"student_id\", \"\")\n        pin = request.form.get(\"pin\", \"\")\n\n        db = pymysql.connect(\n            host=\"localhost\", user=\"root\", passwd=\"\", db=\"university\"\n        )\n        cursor = db.cursor()\n\n        # VULNERABLE: untrusted student_id concatenated into the query\n        query = (\n            \"SELECT * FROM students \"\n            \"WHERE student_id = '\" + student_id + \"' AND pin = %s\"\n        )\n\n        cursor.execute(query, (pin,))\n        row = cursor.fetchone()\n\n        if row:\n            session[\"student_id\"] = student_id\n            return \"Student login successful\"\n        else:\n            return \"Invalid student ID or PIN\", 401\n\n    except Exception as exc:\n        return f\"Error: {exc}\", 500\n    finally:\n        if db is not None:\n            db.close()\n"
      }
    ],
    "cwe": "CWE-203",
    "cwe_description": "Exposure of Sensitive Information to an Unauthorized Actor",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `student_id` into the SQL query. This can lead to exposure of sensitive information, which aligns with the CodeQL finding of potential stack trace exposure. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "10subquery_injection.py",
        "line": 36,
        "full_file": "\"\"\"\nExample 10 \u2013 Subquery/IN-list SQL injection (HR recruitment portal)\n\nThis Flask endpoint exports applicant records based on a list of IDs.\nIt is vulnerable because the `ids` parameter is inserted into an IN(...) list\ndirectly as text.\n\"\"\"\n\nimport psycopg2\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\n\n@app.route(\"/export_applicants\")\ndef export_applicants():\n    \"\"\"Export applicants whose IDs are provided as a CSV list.\n\n    SQL injection vulnerability:\n    - `ids` string is interpolated directly into an IN (...) clause.\n    - Attackers can inject arbitrary subqueries or modify the WHERE clause.\n    \"\"\"\n    ids = request.args.get(\"ids\", \"\")  # e.g. \"1,2,3\"\n\n    conn = psycopg2.connect(\n        dbname=\"hr_portal\", user=\"hr_user\", password=\"hr_pass\", host=\"localhost\"\n    )\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: `ids` pasted directly into IN list\n        query = (\n            \"SELECT id, full_name, email, status \"\n            \"FROM applicants WHERE id IN (\" + ids + \")\"\n        )\n        cur.execute(query)\n        rows = cur.fetchall()\n\n        lines = [\"id,full_name,email,status\"]\n        for r in rows:\n            lines.append(f\"{r[0]},{r[1]},{r[2]},{r[3]}\")\n        csv_data = \"\\n\".join(lines)\n\n        return Response(\n            csv_data,\n            mimetype=\"text/csv\",\n            headers={\"Content-Disposition\": \"attachment; filename=applicants.csv\"},\n        )\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct insertion of the `ids` parameter into the SQL query's IN clause without proper sanitization or parameterization. This allows attackers to inject arbitrary SQL, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "15layered_concatenation_injection.py",
        "line": 64,
        "full_file": "\"\"\"\nExample 15 \u2013 Layered string concatenation SQL injection (Food delivery analytics)\n\nThis module builds a reporting query across several helper functions.\nIt is vulnerable because user-provided filters are threaded through\nmultiple functions and concatenated into the final query string.\n\"\"\"\n\nimport sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n\ndef base_query() -> str:\n    \"\"\"Return the base SELECT clause for the analytics report.\"\"\"\n    return (\n        \"SELECT restaurant_name, COUNT(*) AS num_orders, \"\n        \"SUM(total_price) AS revenue FROM orders \"\n    )\n\n\ndef add_time_filter(sql: str, start: str, end: str) -> str:\n    \"\"\"Append a time window filter to the SQL string.\n\n    Note: This function does not itself introduce a vulnerability, but\n    it builds on the unescaped start/end values passed from above.\n    \"\"\"\n    if start and end:\n        sql += (\n            \"WHERE created_at BETWEEN '\" + start + \"' AND '\" + end + \"' \"\n        )\n    return sql\n\n\ndef add_grouping(sql: str) -> str:\n    \"\"\"Append GROUP BY and ORDER BY clauses.\"\"\"\n    sql += \"GROUP BY restaurant_name ORDER BY revenue DESC\"\n    return sql\n\n\n@app.route(\"/report\")\ndef report():\n    \"\"\"Generate a revenue report for a food delivery platform.\n\n    SQL injection vulnerability:\n    - `start` and `end` date filters are threaded through helper functions.\n    - They are concatenated into the WHERE clause without parameterization,\n      making the final SQL string injectable.\n    \"\"\"\n    start = request.args.get(\"start\", \"\")\n    end = request.args.get(\"end\", \"\")\n\n    sql = base_query()\n    sql = add_time_filter(sql, start, end)\n    sql = add_grouping(sql)\n\n    conn = sqlite3.connect(\"food_delivery.db\")\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: final query contains unescaped start/end from user\n        print(f\"[DEBUG] Executing report query: {sql}\")\n        cur.execute(sql)\n        rows = cur.fetchall()\n\n        data = [\n            {\n                \"restaurant\": r[0],\n                \"num_orders\": r[1],\n                \"revenue\": float(r[2]),\n            }\n            for r in rows\n        ]\n        return jsonify(data)\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the concatenation of user-provided `start` and `end` parameters into the SQL query without proper sanitization or parameterization. This allows attackers to inject arbitrary SQL, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "1simple_where_clause_injection.py",
        "line": 40,
        "full_file": "\"\"\"\nExample 1 \u2013 Simple WHERE-clause SQL injection (University student portal)\n\nThis Flask endpoint checks student login credentials against a MySQL database.\nIt is vulnerable because it directly interpolates the `student_id` into the\nWHERE clause of the SQL query using string concatenation.\n\"\"\"\n\nimport pymysql\nfrom flask import Flask, request, session\n\napp = Flask(__name__)\napp.secret_key = \"dev-secret-key\"\n\n\n@app.route(\"/student/login\", methods=[\"POST\"])\ndef student_login():\n    \"\"\"Authenticate a student by ID and PIN.\n\n    SQL injection vulnerability:\n    - `student_id` from the request is concatenated directly into the SQL string.\n    - An attacker can inject arbitrary SQL into the WHERE clause.\n    \"\"\"\n    db = None\n    try:\n        student_id = request.form.get(\"student_id\", \"\")\n        pin = request.form.get(\"pin\", \"\")\n\n        db = pymysql.connect(\n            host=\"localhost\", user=\"root\", passwd=\"\", db=\"university\"\n        )\n        cursor = db.cursor()\n\n        # VULNERABLE: untrusted student_id concatenated into the query\n        query = (\n            \"SELECT * FROM students \"\n            \"WHERE student_id = '\" + student_id + \"' AND pin = %s\"\n        )\n\n        cursor.execute(query, (pin,))\n        row = cursor.fetchone()\n\n        if row:\n            session[\"student_id\"] = student_id\n            return \"Student login successful\"\n        else:\n            return \"Invalid student ID or PIN\", 401\n\n    except Exception as exc:\n        return f\"Error: {exc}\", 500\n    finally:\n        if db is not None:\n            db.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct interpolation of the `student_id` into the SQL query's WHERE clause using string concatenation. This allows attackers to inject arbitrary SQL, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "3union_based_injection.py",
        "line": 40,
        "full_file": "\"\"\"\nExample 3 \u2013 UNION-based SQL injection (E-commerce product search)\n\nThis Flask endpoint allows users to search products by keyword.\nIt is vulnerable because the search term is interpolated into the SQL query,\nenabling UNION-based attacks to extract other data from the database.\n\"\"\"\n\nimport psycopg2\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n\n@app.route(\"/search\")\ndef search_products():\n    \"\"\"Search for products by keyword.\n\n    SQL injection vulnerability:\n    - `q` is injected into a LIKE clause using f-strings.\n    - An attacker can close the string and append a UNION SELECT payload.\n    \"\"\"\n    q = request.args.get(\"q\", \"\")\n\n    conn = psycopg2.connect(\n        dbname=\"shop\",\n        user=\"shop_user\",\n        password=\"shop_pass\",\n        host=\"localhost\",\n        port=5432,\n    )\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: unescaped `q` directly in f-string\n        query = (\n            f\"SELECT id, name, price FROM products \"\n            f\"WHERE name ILIKE '%{q}%' AND is_active = TRUE\"\n        )\n        cur.execute(query)\n        rows = cur.fetchall()\n\n        results = [\n            {\"id\": r[0], \"name\": r[1], \"price\": float(r[2])}\n            for r in rows\n        ]\n        return jsonify(results)\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct interpolation of the `q` parameter into the SQL query using f-strings without proper sanitization or parameterization. This allows attackers to inject arbitrary SQL, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "4order_by_injection.py",
        "line": 36,
        "full_file": "\"\"\"\nExample 4 \u2013 ORDER BY SQL injection (Crowdsourcing taxi app)\n\nThis FastAPI endpoint lists nearby drivers sorted by criteria.\nIt is vulnerable because the `sort` parameter is interpolated into the ORDER BY\nclause, allowing attackers to inject arbitrary SQL fragments.\n\"\"\"\n\nfrom fastapi import FastAPI, Query\nimport mysql.connector\n\napp = FastAPI()\n\n\n@app.get(\"/drivers\")\ndef list_drivers(sort: str = Query(\"rating\")):\n    \"\"\"List available drivers sorted by the requested field.\n\n    SQL injection vulnerability:\n    - `sort` is used directly in an ORDER BY clause via string formatting.\n    - Attackers can inject expressions like `rating DESC; DROP TABLE drivers`.\n    \"\"\"\n    conn = mysql.connector.connect(\n        host=\"localhost\",\n        user=\"root\",\n        password=\"\",\n        database=\"taxi_app\",\n    )\n    try:\n        cur = conn.cursor(dictionary=True)\n\n        base = \"SELECT id, name, rating, completed_trips FROM drivers WHERE online = 1\"\n\n        # VULNERABLE: ORDER BY field fully controlled by client\n        query = f\"{base} ORDER BY {sort}\"\n        cur.execute(query)\n        rows = cur.fetchall()\n        return rows\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct interpolation of the `sort` parameter into the SQL query's ORDER BY clause without proper sanitization or parameterization. This allows attackers to inject arbitrary SQL fragments, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "5limit_offset_injection.py",
        "line": 39,
        "full_file": "\"\"\"\nExample 5 \u2013 LIMIT/OFFSET SQL injection (Social media feed)\n\nThis Flask endpoint returns paginated posts for a social media feed.\nIt is vulnerable because page and page_size are concatenated into LIMIT/OFFSET,\nenabling injection through numeric parameters.\n\"\"\"\n\nimport sqlite3\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n\n@app.route(\"/feed\")\ndef get_feed():\n    \"\"\"Return a page of posts for the current user.\n\n    SQL injection vulnerability:\n    - `page` and `page_size` are concatenated directly into LIMIT/OFFSET.\n    - Attackers can inject extra clauses or large values to disrupt queries.\n    \"\"\"\n    page = request.args.get(\"page\", \"1\")\n    page_size = request.args.get(\"page_size\", \"20\")\n\n    conn = sqlite3.connect(\"social.db\")\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: numeric parameters concatenated into SQL\n        offset = (int(page) - 1) * int(page_size)\n        query = (\n            \"SELECT id, author, content FROM posts \"\n            \"WHERE is_deleted = 0 \"\n            \"ORDER BY created_at DESC \"\n            \"LIMIT \" + page_size + \" OFFSET \" + str(offset)\n        )\n\n        cur.execute(query)\n        rows = cur.fetchall()\n        posts = [\n            {\"id\": r[0], \"author\": r[1], \"content\": r[2]}\n            for r in rows\n        ]\n        return jsonify(posts)\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `page` and `page_size` parameters into the SQL query's LIMIT/OFFSET clause without proper sanitization or parameterization. This allows attackers to inject arbitrary SQL or manipulate the query, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "6identifier_injection.py",
        "line": 41,
        "full_file": "\"\"\"\nExample 6 \u2013 Identifier (table/column) SQL injection (Multi-tenant analytics)\n\nThis Flask endpoint lets an admin query different tenant metrics tables.\nIt is vulnerable because the `dataset` parameter is used directly as a table\nname, allowing injection of arbitrary identifiers and SQL.\n\"\"\"\n\nimport psycopg2\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n\n@app.route(\"/metrics\")\ndef get_metrics():\n    \"\"\"Fetch aggregated metrics from a dynamically chosen table.\n\n    SQL injection vulnerability:\n    - `dataset` is interpolated into the FROM clause as a table name.\n    - Attackers can choose arbitrary tables or inject further SQL.\n    \"\"\"\n    dataset = request.args.get(\"dataset\", \"visits\")\n\n    conn = psycopg2.connect(\n        dbname=\"analytics\",\n        user=\"analytics_user\",\n        password=\"secret\",\n        host=\"localhost\",\n    )\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: dataset used directly as identifier\n        query = (\n            f\"SELECT date, total_users, active_users \"\n            f\"FROM tenant_{dataset}_daily_summary \"\n            f\"ORDER BY date DESC LIMIT 30\"\n        )\n\n        cur.execute(query)\n        rows = cur.fetchall()\n        return jsonify(\n            [\n                {\n                    \"date\": str(r[0]),\n                    \"total_users\": r[1],\n                    \"active_users\": r[2],\n                }\n                for r in rows\n            ]\n        )\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct interpolation of the `dataset` parameter into the SQL query's FROM clause without proper sanitization or parameterization. This allows attackers to choose arbitrary tables or inject further SQL, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/sql-injection",
    "message": "This SQL query depends on a [user-provided value](1).",
    "locations": [
      {
        "uri": "8stored_procedure_injection.py",
        "line": 36,
        "full_file": "\"\"\"\nExample 8 \u2013 Stored procedure SQL injection (Banking transaction history)\n\nThis Flask endpoint calls a stored procedure to fetch a customer's\ntransaction history. It is vulnerable because the account number is\ninserted into a dynamic CALL statement.\n\"\"\"\n\nimport mysql.connector\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n\n@app.route(\"/transactions\")\ndef transactions():\n    \"\"\"Return transaction history for a given bank account.\n\n    SQL injection vulnerability:\n    - `account` is interpolated into a CALL statement using string formatting.\n    - Attackers can inject extra arguments or terminate the call and append SQL.\n    \"\"\"\n    account = request.args.get(\"account\", \"\")\n\n    conn = mysql.connector.connect(\n        host=\"localhost\",\n        user=\"bank_user\",\n        password=\"bank_pass\",\n        database=\"banking\",\n    )\n    try:\n        cur = conn.cursor(dictionary=True)\n\n        # VULNERABLE: dynamic stored procedure call\n        call_sql = \"CALL get_transactions_for_account('%s')\" % account\n        cur.execute(call_sql)\n        rows = cur.fetchall()\n\n        return jsonify(rows)\n    finally:\n        conn.close()\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "Improper neutralization of special elements used in an SQL command ('SQL Injection').",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct interpolation of the `account` parameter into the stored procedure call without proper sanitization or parameterization. This allows attackers to inject extra arguments or terminate the call and append SQL, confirming the CodeQL finding of a potential SQL injection vulnerability. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "CodeQL",
    "rule_id": "py/clear-text-logging-sensitive-data",
    "message": "This expression logs [sensitive data (private)](1) as clear text.",
    "locations": [
      {
        "uri": "2boolean_condition_injection.py",
        "line": 25,
        "full_file": "\"\"\"\nExample 2 \u2013 Boolean/conditional SQL injection (Hospital patient lookup)\n\nThis script provides a simple CLI to look up patient records by numeric ID.\nIt is vulnerable because the `patient_id` input is appended directly to the query\nwithout validation or parameterization, allowing boolean-condition injections.\n\"\"\"\n\nimport sqlite3\n\n\ndef get_patient_record(patient_id: str) -> None:\n    \"\"\"Fetch a patient record by patient_id from an SQLite database.\n\n    SQL injection vulnerability:\n    - `patient_id` is directly concatenated into the WHERE condition.\n    - Attackers can inject expressions like `1 OR 1=1` to bypass checks.\n    \"\"\"\n    conn = sqlite3.connect(\"hospital.db\")\n    try:\n        cursor = conn.cursor()\n\n        # VULNERABLE: `patient_id` used directly in numeric condition\n        query = \"SELECT id, full_name, diagnosis FROM patients WHERE id = \" + patient_id\n        print(f\"[DEBUG] Executing: {query}\")\n        cursor.execute(query)\n        row = cursor.fetchone()\n\n        if row:\n            print(\"Patient:\", row)\n        else:\n            print(\"No patient found with that ID.\")\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    user_input = input(\"Enter patient ID: \")\n    get_patient_record(user_input)\n"
      }
    ],
    "cwe": "CWE-532",
    "cwe_description": "Insecure logging of sensitive information such as passwords, credit card numbers, or personal data.",
    "agent_validation": "The analysis of the provided code confirms that it contains a vulnerability related to logging sensitive data as clear text, specifically the `patient_id` which is printed in the debug statement. This can expose sensitive information if the logs are accessed by unauthorized users, confirming the CodeQL finding of potential clear-text logging of sensitive data. Therefore, I classify this finding as a True Positive and will update the JSON accordingly."
  },
  {
    "tool": "None",
    "rule_id": "None",
    "message": "No vulnerability detected by CodeQL",
    "locations": [
      {
        "uri": "7stacked_query_injection.py",
        "line": 0,
        "full_file": "\"\"\"\nExample 7 \u2013 Stacked query SQL injection (Inventory admin tool)\n\nThis CLI tool allows an admin to adjust product stock levels.\nIt is vulnerable because the `product_id` is concatenated into the WHERE clause\ninside a driver that permits multiple statements, enabling stacked queries.\n\"\"\"\n\nimport pymysql\n\n\ndef adjust_stock(product_id: str, delta: int) -> None:\n    \"\"\"Adjust stock for a product by a positive or negative delta.\n\n    SQL injection vulnerability:\n    - `product_id` is interpolated directly into the statement.\n    - On drivers that allow multi-statements, attackers can append `; DROP TABLE` etc.\n    \"\"\"\n    conn = pymysql.connect(\n        host=\"localhost\",\n        user=\"root\",\n        password=\"\",\n        db=\"inventory\",\n        client_flag=pymysql.constants.CLIENT.MULTI_STATEMENTS,\n    )\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: product_id directly concatenated, allowing stacked queries\n        query = (\n            \"UPDATE products SET stock = stock + %s WHERE id = \"\n            + product_id\n        )\n        cur.execute(query, (delta,))\n        conn.commit()\n        print(\"Stock updated.\")\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    pid = input(\"Product ID to adjust: \")\n    diff = int(input(\"Change in stock (e.g. -5, 10): \"))\n    adjust_stock(pid, diff)\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "SQL Injection",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `product_id` into the SQL query without proper sanitization or parameterization. This allows attackers to exploit the query by appending additional SQL commands, such as `; DROP TABLE`, which confirms the existence of a vulnerability despite CodeQL not flagging it. Therefore, I classify this finding as a New Vulnerability and will update the JSON accordingly."
  },
  {
    "tool": "None",
    "rule_id": "None",
    "message": "No vulnerability detected by CodeQL",
    "locations": [
      {
        "uri": "12second_order_injection.py",
        "line": 0,
        "full_file": "\"\"\"\nExample 12 \u2013 Second-order SQL injection (Bug tracker comments)\n\nThis script first stores user comments, then later uses stored comments\nto build a dynamic query for moderation. Unsafe data is used in a later\nquery, demonstrating second-order SQL injection.\n\"\"\"\n\nimport sqlite3\n\n\ndef store_comment(issue_id: int, raw_comment: str) -> None:\n    \"\"\"Store a user comment as-is in the database.\"\"\"\n    conn = sqlite3.connect(\"bugs.db\")\n    try:\n        cur = conn.cursor()\n        cur.execute(\n            \"INSERT INTO comments (issue_id, raw_text) VALUES (?, ?)\",\n            (issue_id, raw_comment),\n        )\n        conn.commit()\n    finally:\n        conn.close()\n\n\ndef moderate_comments(pattern: str) -> None:\n    \"\"\"Search previously stored comments using a dynamically built query.\n\n    SQL injection vulnerability (second-order):\n    - A malicious pattern might have been stored earlier via store_comment.\n    - Here, `pattern` is concatenated into the WHERE clause, enabling injection\n      when that pattern was user-controlled at insertion time.\n    \"\"\"\n    conn = sqlite3.connect(\"bugs.db\")\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: `pattern` used directly in LIKE; may have been stored from user input\n        query = (\n            \"SELECT id, issue_id, raw_text FROM comments \"\n            \"WHERE raw_text LIKE '%\" + pattern + \"%'\"\n        )\n        print(f\"[DEBUG] Executing: {query}\")\n        cur.execute(query)\n\n        for row in cur.fetchall():\n            print(row)\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    # Example usage for demonstration, not secure.\n    store_comment(1, input(\"Enter a comment for issue #1: \"))\n    search = input(\"Enter pattern for moderation search: \")\n    moderate_comments(search)\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "SQL Injection",
    "agent_validation": "The analysis of the provided code confirms that it contains a second-order SQL injection vulnerability due to the direct concatenation of the `pattern` parameter into the SQL query's WHERE clause without proper sanitization or parameterization. This allows for the possibility of SQL injection when the `pattern` is derived from user input stored earlier, confirming the existence of a vulnerability despite CodeQL not flagging it. Therefore, I classify this finding as a New Vulnerability and will update the JSON accordingly."
  },
  {
    "tool": "None",
    "rule_id": "None",
    "message": "No vulnerability detected by CodeQL",
    "locations": [
      {
        "uri": "9like_pattern_injection.py",
        "line": 0,
        "full_file": "\"\"\"\nExample 9 \u2013 LIKE/pattern SQL injection (Library catalog search)\n\nThis Django view function searches books by title or author.\nIt is vulnerable because the search string is concatenated into a LIKE pattern\nwithout escaping, allowing injection and pattern manipulation.\n\"\"\"\n\nfrom django.http import JsonResponse\nfrom django.db import connection\n\n\ndef search_books(request):\n    \"\"\"Search books by free-text query.\n\n    SQL injection vulnerability:\n    - `q` is concatenated into a LIKE clause inside raw SQL.\n    - An attacker can break out of the string or control wildcards.\n    \"\"\"\n    q = request.GET.get(\"q\", \"\")\n\n    with connection.cursor() as cursor:\n        # VULNERABLE: unescaped search term in LIKE pattern\n        sql = (\n            \"SELECT id, title, author FROM books \"\n            \"WHERE title LIKE '%\" + q + \"%' \"\n            \"   OR author LIKE '%\" + q + \"%' \"\n            \"ORDER BY title ASC\"\n        )\n        cursor.execute(sql)\n        rows = cursor.fetchall()\n\n    data = [{\"id\": r[0], \"title\": r[1], \"author\": r[2]} for r in rows]\n    return JsonResponse(data, safe=False)\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "SQL Injection",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `q` parameter into the SQL query's LIKE clause without proper sanitization or parameterization. This allows attackers to manipulate the query by injecting SQL code, confirming the existence of a vulnerability despite CodeQL not flagging it. Therefore, I classify this finding as a New Vulnerability and will update the JSON accordingly."
  },
  {
    "tool": "None",
    "rule_id": "None",
    "message": "No vulnerability detected by CodeQL",
    "locations": [
      {
        "uri": "11ddl_admin_injection.py",
        "line": 0,
        "full_file": "\"\"\"\nExample 11 \u2013 DDL/admin SQL injection (CMS maintenance console)\n\nThis administrative script allows dropping or truncating content tables\nfrom a CMS. It is vulnerable because the table name is taken from user\ninput and concatenated directly into a DDL statement.\n\"\"\"\n\nimport sqlite3\n\n\ndef drop_or_truncate(table_name: str, mode: str) -> None:\n    \"\"\"Drop or truncate a table in the CMS database.\n\n    SQL injection vulnerability:\n    - `table_name` is used directly in DDL statements.\n    - Attackers can inject additional DDL or target arbitrary tables.\n    \"\"\"\n    conn = sqlite3.connect(\"cms.db\")\n    try:\n        cur = conn.cursor()\n\n        if mode == \"drop\":\n            # VULNERABLE: unvalidated table name in DROP statement\n            sql = \"DROP TABLE \" + table_name\n        else:\n            # VULNERABLE: unvalidated table name in DELETE statement\n            sql = \"DELETE FROM \" + table_name\n\n        print(f\"[DEBUG] Executing: {sql}\")\n        cur.execute(sql)\n        conn.commit()\n        print(\"Operation completed.\")\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    name = input(\"Enter table name to manage: \")\n    action = input(\"Enter 'drop' or 'truncate': \")\n    drop_or_truncate(name, action)\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "SQL Injection",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `table_name` parameter into the SQL DDL statements without proper sanitization or parameterization. This allows attackers to inject additional DDL or target arbitrary tables, confirming the existence of a vulnerability despite CodeQL not flagging it. Therefore, I classify this finding as a New Vulnerability and will update the JSON accordingly."
  },
  {
    "tool": "None",
    "rule_id": "None",
    "message": "No vulnerability detected by CodeQL",
    "locations": [
      {
        "uri": "13orm_raw_sql_injection.py",
        "line": 0,
        "full_file": "\"\"\"\nExample 13 \u2013 ORM raw SQL injection (Event ticket booking system)\n\nThis Django view uses the ORM infrastructure but drops down to raw SQL\nfor a complex query. It is vulnerable because it concatenates user input\ninto the raw SQL string.\n\"\"\"\n\nfrom django.http import JsonResponse\nfrom django.db import connection\nfrom django.views.decorators.http import require_GET\n\n\n@require_GET\ndef search_bookings(request):\n    \"\"\"Search event bookings by free-text reference.\n\n    SQL injection vulnerability:\n    - `ref` is concatenated into a raw SQL query.\n    - Using Django's `connection.cursor()` and raw SQL circumvents ORM protections.\n    \"\"\"\n    ref = request.GET.get(\"ref\", \"\")\n\n    with connection.cursor() as cursor:\n        # VULNERABLE: unescaped ref parameter in raw SQL\n        sql = (\n            \"SELECT id, user_email, event_name, status \"\n            \"FROM ticket_bookings \"\n            \"WHERE booking_reference LIKE '%\" + ref + \"%'\"\n        )\n        cursor.execute(sql)\n        rows = cursor.fetchall()\n\n    data = [\n        {\"id\": r[0], \"user_email\": r[1], \"event_name\": r[2], \"status\": r[3]}\n        for r in rows\n    ]\n    return JsonResponse(data, safe=False)\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "SQL Injection",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `ref` parameter into the raw SQL query without proper sanitization or parameterization. This allows attackers to manipulate the SQL query, confirming the existence of a vulnerability despite CodeQL not flagging it. Therefore, I classify this finding as a New Vulnerability and will update the JSON accordingly."
  },
  {
    "tool": "None",
    "rule_id": "None",
    "message": "No vulnerability detected by CodeQL",
    "locations": [
      {
        "uri": "14platform_specific_function_injection.py",
        "line": 0,
        "full_file": "\"\"\"\nExample 14 \u2013 Platform-specific function SQL injection (Log export tool)\n\nThis script uses PostgreSQL's COPY command to export query results.\nIt is vulnerable because the filter value is embedded directly into a\nWHERE clause, which is then passed to COPY.\n\"\"\"\n\nimport psycopg2\n\n\ndef export_logs(level: str):\n    \"\"\"Export application logs with a given level to a CSV file.\n\n    SQL injection vulnerability:\n    - `level` is concatenated into a WHERE clause in the COPY query.\n    - Attackers can inject arbitrary SQL into the COPY statement.\n    \"\"\"\n    conn = psycopg2.connect(\n        dbname=\"logs_db\", user=\"logs_user\", password=\"logs_pass\", host=\"localhost\"\n    )\n    try:\n        cur = conn.cursor()\n\n        # VULNERABLE: `level` directly in WHERE clause\n        query = (\n            \"COPY (\"\n            \"SELECT timestamp, level, message \"\n            \"FROM app_logs WHERE level = '\" + level + \"'\"\n            \") TO STDOUT WITH CSV HEADER\"\n        )\n\n        with open(\"logs_export.csv\", \"w\", encoding=\"utf-8\") as f:\n            cur.copy_expert(query, f)\n        print(\"Logs exported.\")\n    finally:\n        conn.close()\n\n\nif __name__ == \"__main__\":\n    lvl = input(\"Enter log level to export (e.g. INFO, ERROR): \")\n    export_logs(lvl)\n"
      }
    ],
    "cwe": "CWE-89",
    "cwe_description": "SQL Injection",
    "agent_validation": "The analysis of the provided code confirms that it contains a SQL injection vulnerability due to the direct concatenation of the `level` parameter into the SQL query's WHERE clause without proper sanitization or parameterization. This allows attackers to inject arbitrary SQL into the COPY statement, confirming the existence of a vulnerability despite CodeQL not flagging it. Therefore, I classify this finding as a New Vulnerability and will update the JSON accordingly."
  }
]