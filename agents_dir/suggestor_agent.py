""" 
Module that defines the SuggestorAgent, a ReAct agent that reads the Analyzer Agent's results, 
identifies the detected vulnerabilities and creates:
    - a detailed report
    - suggestions for new improved and predictive CodeQL queries
    - structured reasonings (summary -> thought -> action)

Contains:
    - SuggestorInput: input task for the SuggestorAgent
    - SuggestorOutput: output task from the SuggestorAgent
    - SuggestorAgent: autonomous agent that executes analysis and realizes suggestions

Main functionalities:
    - step-by-step reasoning through ReActChain
    - tool call and creation
    - shared memory management
    - loading of existing CodeQL queries for ispiration  
"""

import json
import os
from tools import ExistingQuery
from typing import List, Set
import re

from pydantic import Field
from agents_dir.base_agent import BaseAgent, ReActChain, SharedMemory, BaseTaskInput
from prompts import SYSTEM_SUGGESTOR, SUMMARY_TEMPLATE, THOUGHT_TEMPLATE, ACTION_TEMPLATE
from procedures.summ_procedure import SummaryProcedure
from procedures.action_procedure import ActionProcedure
from procedures.tought_procedure import ThoughtProcedure
from config import OUTPUT_QUERIES_PATH


QUERY_PACK_TOT = "/Users/rebeccaderosa/.codeql/packages/codeql/python-queries/1.6.8/Security"
# path content:
# CVE-2018-1281           CWE-094                 CWE-295                 CWE-614
# CWE-020                 CWE-1004                CWE-312                 CWE-643
# CWE-020-ExternalAPIs    CWE-113                 CWE-326                 CWE-730
# CWE-022                 CWE-116                 CWE-327                 CWE-732
# CWE-074                 CWE-117                 CWE-352                 CWE-776
# CWE-078                 CWE-1275                CWE-377                 CWE-798
# CWE-079                 CWE-209                 CWE-502                 CWE-918
# CWE-089                 CWE-215                 CWE-601                 CWE-943
# CWE-090                 CWE-285                 CWE-611

class SuggestorInput(BaseTaskInput):
    """
    SuggestorAgent input.
    
    Args:
        report_content (str): report content created by the Analyzer Agent.
    """
    report_content: str = Field(...)

class SuggestorOutput(BaseTaskInput):
    """
    SuggestorAgent output.
    
    Args:
        final_report (str): output report generated by the SuggestorAgent.
    """
    final_report: str = Field(...)


class SuggestorAgent(BaseAgent):
    """
    ReAct Agent that has the main role of generating new CodeQL queries suggestions.
    
    The Agent:
        - reads the SARIF report from the Analyzer Agent 
        - extracts and analyzes the vulnerabilities
        - proposes suggestions for creating new, better and predictive CodeQL queries for the same vulnerabilities.
        - reasons step-by-step (summaty -> thought -> action)
        - uses specialized tools when needed
    
    Args: 
        shared_memory (SharedMemory): memory shared among agents
        tools (list): available tools to call when needed
        logpath (str| None=None): file path where logs are saved
        
    Attributes:
        prompt_template (str): A template string for formatting the agent's prompt.
        summ_procedure (SummaryProcedure): summary procedure
        thought_procedure (ThoughtProcedure): reasoning procedure
        action_procedure (ActionProcedure): action procedure
        max_steps (int): maximum number of reasoning steps
        processed_cwe (Set[str]): already processed CWEs in order to avoid duplicants
        report_items (List[dict]): structures list of SARIF elements
        all_actions (list): all actions performed at each step from the suggestor for each vulnerability
    
    Methods:
        reset(task_input): resets the agent state for a new task
        load_existing_queries(cwe): loads existing CodeQL queries for one CWE from the local CodeQL packet
        step(observation): execute eache single step of the ReAct cycle
        run(): executed the entire reasoning cycle of the SuggestorAgent
    """

  
    def __init__(self, shared_memory: SharedMemory, tools: list, logpath: str| None=None):
        """
        SuggestorAgent constructor.

        It initializes summary, thought, and action procedures, as well as structures
        internal for tracking CWEs and the report.

        Args:
            shared_memory (SharedMemory): memory shared among agents
            tools (list): available tools to call when needed
            logpath (str| None=None): file path where logs are saved
        """
       
        super().__init__(prompt_template=SYSTEM_SUGGESTOR, shared_memory=shared_memory, tools=tools, logpath=logpath)
       
    
        self.summ_procedure=SummaryProcedure(self.llm, SUMMARY_TEMPLATE)
        self.thought_procedure=ThoughtProcedure(self.llm, THOUGHT_TEMPLATE)
        self.action_procedure = ActionProcedure(self.llm, ACTION_TEMPLATE)

        self.max_steps=20
        self.processed_cwes: Set[str] = set()
        self.report_items: List[dict] = []

        self.all_actions = []
        
       

    def reset(self, task_input: BaseTaskInput):
        """
        Resets the agent state for a new task.
        
        If the input is a SuggestorInput, it extracts and saves the SARIF report content
        as first observation and initializes the processed_cwes list
        
        Args:
            task_input (BaseTaskInput): task input, preferably SuggestorInput.
        """
        super().reset(task_input)
        
        if isinstance(task_input, SuggestorInput):
            items = json.loads(task_input.report_content)

            for item in items:
                if not item.get("cwe") or str(item.get("cwe")) == "None":
                    text = item.get("agent_validation", "").lower()
                    if "sql injection" in text:
                        item["cwe"] = "CWE-89"
                        item["cwe_description"] = "SQL Injection"
                        print("Andata\n")
                    elif "xss" in text:
                        item["cwe"] = "CWE-79"
                        item["cwe_description"] = "Croos-Site Scripting"
                    elif "command injection" in text:
                        item["cwe"] = "CWE-78"
                        item["cwe_description"] = "OS Command Injection"
               
            with open("analyzer_report.json", "w", encoding="utf-8") as f:
                f.write(json.dumps(items, indent=2))
            print("Complete Analyzer report saved in 'analyzer_reoport.json\n")

            self.report_items = items    
            self.last_step.observation=json.dumps(items)
            self.processed_cwes.clear()
            self.all_actions = []
            

    def summarize(self, query: str, text: str) -> str:
        if len(text)< 1000:
            return text

        summary_prompt = f"""
        Analyze the following web search result for the query: "{query}".
        Extracr only the relevantiinfomrations like:
        - the CodeQL classes, predicates or library names mentioned.
        - specific AST elements (Sources, Sinks).
        - code snippets or logic patterns for TainTracking.
        Discard all navigation menus, ads and irrelevant prose.
        Result to summarize: {text[:8000]}
        """

        response = self.llm.invoke(summary_prompt)
        return f"Compressed web search result: {response.content}"
   
    def load_existing_queries(self, cwe: str):
        """
        Loads existing CodeQL queries for one CWE from the local CodeQL packet.
        
        Args:
            cwe (str): vulnerability ID

        Returns:
            List[dict]: existing queries, each with:
                - filename
                - content
        """
            
        num = int(cwe[4:])           
        cwe = f"CWE-{num:03d}"
        cwe_path = os.path.join(QUERY_PACK_TOT, cwe)

        if not os.path.exists(cwe_path):
            return []
        
        queries = []
        for file in os.listdir(cwe_path):
            if file.endswith(".ql"):
                try:
                    with open(os.path.join(cwe_path, file), "r") as f:
                        queries.append({
                            "filename": file,
                            "content": f.read()
                        })
                except Exception:
                    continue

        if os.listdir(OUTPUT_QUERIES_PATH):
            for file in os.listdir(OUTPUT_QUERIES_PATH):
                if file.endswith(".ql"):
                    try:
                        with open(file, "r") as f:
                            queries.append({
                                "filename": file,
                                "content": f.read()
                            })
                    except Exception:
                        continue


        return queries

    def step(self, observation: str) -> ReActChain:
        """
        Execute eache single step of the ReAct cycle.
        
        The cycle includes:
            1. memory update
            2. summary generation
            3. reasoning (thought)
            4. selection/creation next action
            5. existing CodeQL queries integration as inspiration
        
        Args: 
            observation (str): new observation to process
        
        Returns:
            ReActChain: updated chain containing summary, thought and action.

        """

        self.update_memory(observation)

        scratchpad = self.shared_memory.to_messages()[-10:]
        instructions = self.prompt_template 

        summary_out = self.summ_procedure.run(instructions, scratchpad)
        summary = summary_out.summary

        thought_out =self.thought_procedure.run(summary, scratchpad, self.last_step)
        thought = thought_out.thought
        
        action_out = self.action_procedure.run(summary, scratchpad, self.last_step, thought, self.tools)
        action = action_out.action

        if action.__class__.__name__ == "SuggestSubAgent":
            cwe = getattr(action, "cwe", None)
            if cwe:
                self.processed_cwes.add(cwe)
                inspiration_queries = self.load_existing_queries(cwe)
                action.existing_queries = [ExistingQuery(**q) for q in inspiration_queries]
                aggregated_audits = []
                aggregated_contexts = []
                for item in self.report_items:
                    if item.get("cwe") == cwe:
                        audit = item.get("agent_validation")
                        if audit:
                            aggregated_audits.append(audit)
                        
                        for loc in item.get("locations", []):
                            code_context = loc.get("full_file")
                            if code_context and code_context not in aggregated_contexts:
                                aggregated_contexts.append(code_context)

                action.validation_audit = aggregated_audits
                action.code_contexts = aggregated_contexts

                # the suggestor needs to aggreagate all the validation audits for each vulnerability in order to generate a complete report for unique vulnerability
                thought += (f"\nAggregated {len(aggregated_audits)} audits and {len(aggregated_contexts)} code contexts for CWE {cwe}.")

        self.last_step = ReActChain.format(summary=summary, thought=thought, action=action)
        return self.last_step
    
    def run(self) -> SuggestorOutput:
        """
        Executed the entire reasoning cycle of the SuggestorAgent
        
        The method:
            - executes max_step iteractions maximum
            - calls tool depending on the decided action
            - checks if the final action is FinishToolSuggestor
            - created the finel SuggestorOutput report
        
        Returns:
            SuggestorOutput: contains the final report created by the agent
        
        Raises:
            TimeoutError: if the agent exceed max_steps.
        """

        print("[Suggestor]: ")

        all_target_cwes = {
            item.get("cwe") for item in self.report_items
            if item.get("cwe") and item.get("cwe") != "None"
        }
        
        if not all_target_cwes:
            return SuggestorOutput(final_report = "No vulnerabilities indentified by the Analzyer")
            
        last_observation = self.last_step.observation
        available_tools = {tool.__name__: tool for tool in self.tools} # WebSearchTool, SuggestSubAgent, FinishToolSuggestor

               

        for step in range(self.max_steps):

            current_reasoning = self.step(last_observation)            
            current_action = current_reasoning.action

            if not current_action:
                last_observation = "\nERROR: not action decided. Analyze your goal and try again."
                print(f"\nObservation: {last_observation}\n")
                self.update_memory(last_observation)
                continue
            
            action_name = current_action.__class__.__name__

            pending_cwe = all_target_cwes - self.processed_cwes
            if pending_cwe and action_name not in ("SuggestSubAgent", "WebSearchTool"):
                last_observation = f"Pending CWE {pending_cwe}. You must generate a detection plan using SuggestSubAgent or find more information about recent CodeQL documentation with  WebSearchTool."
                self.update_memory(last_observation)
                print(f"\n[{step}] Thought: {current_reasoning.thought}\n")
                continue
           

            print(f"\n[{step}] Thought: {current_reasoning.thought}\n")
            print(f"Action: {action_name}\n")

            if action_name == "FinishToolSuggestor":
                # aggregate all the output (reports) of each step
                full_report = "\n\n".join(self.all_actions)
                self.shared_memory.set_data("target_cwes", list(self.processed_cwes)) # save the list of cwes processed in the memory
                return SuggestorOutput(final_report=full_report)  
            
            if action_name in available_tools:
                try:
                    result = available_tools[action_name](**current_action.dict()).run(self.llm)
                    if action_name=="SuggestSubAgent":
                        self.all_actions.append(result)
                        cwe = getattr(current_action, 'cwe', 'unknown')
                        #pending_cwe = all_target_cwes - self.processed_cwes
                        if pending_cwe:
                            last_observation = f"\nSUCCESS: Detection plan for {cwe} successfully generated and stored. Remaining tool to process: {pending_cwe}\n"
                            self.update_memory(last_observation)
                        else:
                            last_observation = f"SUCCESS: All CWEs processed. You can know call FinishToolSuggestor to summarize."
                            self.update_memory(last_observation)
                            continue
                    
                    if action_name == "WebSearchTool":
                        query = getattr(current_action, 'query', 'CodeQL research')
                        summary_text = self.summarize(query, str(result))
                        last_observation = f"\nResult summarized: {summary_text}"
                        self.update_memory(last_observation)
                   


                except Exception as e:
                    last_observation = f"\nError during {action_name} tool: {e}"
            
            else:
                last_observation = f"\nUnknown action: {action_name}"
                print(last_observation)
                self.update_memory(last_observation)
                continue

            self.update_memory(last_observation)
        
        raise TimeoutError(f"Suggestor exceeded max steps ({self.max_steps})") 

        