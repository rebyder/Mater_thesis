"""
Module that implements the CreatorAgent, the final stage of the multi-agent pipeline for automated CodeQL query generation.

The CreatorAgent:
    - receives the final report produced by the SuggestorAgent
    - identifies all targeted CWEs that require CodeQL query generation
    - iteratively produces one `.ql` file per CWE using reasoning steps and tool invocations (WriteQuerySubAgent and FinishTool)

Main components:
    - CreatorInput: input model containing the final report of the SuggestorAgent
    - CreatorOutput: final message outputs by the CreatorAgent
    - CreatorAgent: autonomous ReAct agent capable of summarizing context, producing thought, choosing actions and generating 
                    CodeQL queries through available tools.

Workflow:
    1. Summarizing of memory and instructions
    2. Generation of though to decide the next action
    3. Tool-based action execution (WriteQuerySubAgent or FinishTool)
    4. Tracking of processed CWEs until all queries are created.

"""


from pydantic import Field
from typing import Set

from agents_dir.base_agent import BaseAgent, SharedMemory, BaseTaskInput, ReActChain
from prompts import SUMMARY_TEMPLATE, THOUGHT_TEMPLATE, SYSTEM_QUERY_CREATOR, ACTION_TEMPLATE
from procedures.summ_procedure import SummaryProcedure
from procedures.action_procedure import ActionProcedure
from procedures.tought_procedure import ThoughtProcedure


class CreatorInput(BaseTaskInput):
    """
    CreatorAgent input.
    
    Args:
        final_report (str): output report generated by the SuggestorAgent.
    """
    final_report: str = Field(...)

class CreatorOutput(BaseTaskInput):
    """
    CreatorAgent output.
    
    Args:
        final_message (str): final message generated by the CreatorAgent.
    """
    final_message: str = Field(...)


class CreatorAgent(BaseAgent):
    """
    ReAct Agent that has the main role of generating new CodeQL `.ql` files based on the
    report from the SuggestorAgent and the list of targeted CWEs.

    The Agent:
        - reads the last observation and updates the shared memory
        - summarized context and task state usinig SummaryProcedure
        - decides the next step with ThoughtProcedure
        - executes an action with ActionProcedure (WriteQuerySubAgent and FinishTool)
        - executes the tool and converts its output into the next observation
    
    Args: 
        shared_memory (SharedMemory): memory shared among agents
        tools (list): available tools to call when needed
        logpath (str| None=None): file path where logs are saved
        
    Attributes:
        prompt_template (str): a template string for formatting the agent's prompt.
        summ_procedure (SummaryProcedure): summary procedure
        thought_procedure (ThoughtProcedure): reasoning procedure
        action_procedure (ActionProcedure): action procedure
        max_steps (int): maximum number of reasoning steps
        all_cwes (set[str]): full set of CWEs extracted from shared memory
        processed_cwes (set[str]): CWEs for which a CodeQL query was already generated.
    
    Methods:
        reset(task_input): resets the agent state for a new task
        step(observation): execute eache single step of the ReAct cycle
        run(): executed the entire reasoning cycle of the CreatorAgent
    """

    def __init__(self, shared_memory: SharedMemory, tools: list, logpath: str | None=None):
        """
        CreatorAgent constructor.
        
        It initializes summary, thought, and action procedures, as well as the CWEs lists.
       
        Args:
            shared_memory (SharedMemory): memory shared among agents
            tools (list): available tools to call when needed
            logpath (str| None=None): file path where logs are saved
        """
        
        super().__init__(prompt_template=SYSTEM_QUERY_CREATOR, shared_memory=shared_memory, tools=tools, logpath=logpath)
        
        self.summ_procedure = SummaryProcedure(self.llm, SUMMARY_TEMPLATE)
        self.thought_procedure = ThoughtProcedure(self.llm, THOUGHT_TEMPLATE)
        self.action_procedure = ActionProcedure(self.llm, ACTION_TEMPLATE)
        self.max_steps = 20
        
        self.all_cwes : Set[str] = set()
        self.max_trials ={}
        self.processed_cwes : Set[str] = set()


    def reset(self, task_input: BaseTaskInput):
        """
        Resets the agent state for a new task.

        This methods:
            - stores the final suggestor report 
            - loads the list of the targets CWEs from shared memory
            - resets "processed_cwes"
            - create a clerare final observation with more precise instructions-

        Args:
            task_input (CreatorInput): task input.
        """

        super().reset(task_input)
        if isinstance(task_input, CreatorInput):
            
            clean_report = task_input.final_report.replace('"', "'")
            self.report = clean_report
            target_cwes = self.shared_memory.get_data("target_cwes", []) 
            self.all_cwes = set(target_cwes)  
            self.processed_cwes.clear()
            self.pending_cwes = set()

            self.last_step.observation = (
                f"NEW task: generate CodeQL queries for the following CWEs: {', '.join(self.all_cwes)}. "
                f"Use the report {self.report} as guidelines."
            )
            
    def summarize(self, query: str, text: str) -> str:
        if len(text)< 1000:
            return text

        summary_prompt = f"""
        Analyze the following web search result for the query: "{query}".
        Extracr only the relevantiinfomrations like:
        - the CodeQL classes, predicates or library names mentioned.
        - specific AST elements (Sources, Sinks).
        - code snippets or logic patterns for TainTracking.
        Discard all navigation menus, ads and irrelevant prose.
        Result to summarize: {text[:8000]}
        """

        response = self.llm.invoke(summary_prompt)
        return f"Compressed web search result: {response.content}"
    
    def step(self, observation: str) -> ReActChain:
        """
        Executes a single reasoning-action step using the ReAct pattern.
        
        The cycle includes:
        1. memory update
        2. summary generation
        3. reasoning (thought)
        4. selection/creation next action

        Args: 
            observation (str): new observation to process
        
        Returns:
            ReActChain: updated chain containing summary, thought and action.
        """

        self.update_memory(observation)
        scratchpad = self.shared_memory.to_messages()
        processed_cwes_str = ", ".join(self.processed_cwes)
        all_cwes_str = ", ".join(self.all_cwes)
        report = self.report
        pending_cwes_str = ", ".join(self.pending_cwes)
        
        instructions = SYSTEM_QUERY_CREATOR.format(
            all_cwes = all_cwes_str,
            report = report,
            processed_cwes = processed_cwes_str,
            pending_cwes = pending_cwes_str
        )

        summary_out = self.summ_procedure.run(instructions, scratchpad)
        summary = summary_out.summary

        thought_out =self.thought_procedure.run(summary, scratchpad, self.last_step)
        thought = thought_out.thought

        action_out = self.action_procedure.run(summary, scratchpad, self.last_step, thought, self.tools)
        action = action_out.action
    
        self.last_step = ReActChain.format(summary=summary, thought=thought, action=action)
        return self.last_step
    

    def run(self) -> CreatorOutput:
        """
        Executes the full CodeQL query creation loop.
        
        Workflow:
            - iteratively run reasoning steps up to max_steps.
            - on each step, detect which tool was selected (WriteQuerySubAgent or FinishTool).
            - handles erorrs such as duplicate CWE attempts.
        
        Returns:
            CreatorOutput: contains final message generated by the CreatorAgent

        Raises:
            TimeoutError: if the agent exceed max_steps.
        """

        available_tools = {tool.__name__: tool for tool in self.tools}
        last_observation = f"The report from the Suggestor has been successfully generated. Now I must generate as queries as necessary following the instruction in the report {self.report}. You MUST start from the CWE-89."
        

        print("[Creator]: ")
        for step in range(self.max_steps):
            current_reasoning = self.step(last_observation)
            current_action = current_reasoning.action

            if not current_action:
                last_observation = (f"ERROR: No valid action. Processed CWEs until now: {', '.join(sorted(self.processed_cwes))}. "
                f"Choose a different CWE or call FinishTool if all are done."
                )
                print(f"Observation: {last_observation}\n")
                self.update_memory(last_observation)
                continue

            action_name = current_action.__class__.__name__

            print(f"\n[{step}] Thought: {current_reasoning.thought}\n")
            print(f"Action: {action_name}") 

            if action_name == "FinishTool":
                return CreatorOutput(final_message="Files created, goal reached!")

            if action_name in available_tools:
                try:

                    result = available_tools[action_name](**current_action.dict()).run(self.llm)
                    current_cwe = getattr(current_action, "cwe", None)
                   

                    if action_name == "WriteQuerySubAgent":
                        if "ERROR" in result:
                            if current_cwe:
                                self.max_trials[current_cwe] = self.max_trials.get(current_cwe, 0)+1
                                if self.max_trials[current_cwe] >= 3:
                                    self.processed_cwes.add(current_cwe)
                                    self.pending_cwes = self.all_cwes - self.processed_cwes
                                    if self.pending_cwes:
                                        last_observation = (f"CWE {current_cwe} failed 3 times."
                                                            f"You MUST NOT generate a query for {current_cwe} anymore. You MUST pick the next cwe in {self.pending_cwes} to generate a new query using the section of the {self.report} related to that CWE as guideline.")
                                        self.last_step.action = current_action
                                    else:
                                        last_observation = f"You MUST call 'FinishTool'"
                                        self.last_step.action = current_action
                                else:
                                    last_observation = f"The query failed (Exit 2) (attempt {self.max_trials[current_cwe]}/3). Error details: {result}. You MUST NOT start the query with '```ql'.  You MUST now use WebSearchTool to find a valid CodeQL Python at this web site `https://codeql.github.com/docs/writing-codeql-queries/` and then try again to genereate the query for {current_cwe} with the new insights." 
                                    self.last_step.action = current_action
                        else:
                            if current_cwe:
                                self.processed_cwes.add(current_cwe)
                            last_observation = result
                            self.last_step.action = current_action
                    
                    if action_name == "WebSearchTool":
                        #query = getattr(current_action, 'query', 'CodeQL research')
                        #summary_text = self.summarize(query, str(result))
                        #last_observation = f"\nResult summarized: {summary_text}"
                        last_observation = result
                        self.last_step.action = current_action
                        #self.update_memory(last_observation)
                    # else:
                    #     last_observation = result

                except Exception as e:
                    last_observation = f"Error during {action_name}: {e}"
                    self.last_step.action =  current_action
                    print(last_observation)

            print(f"Step {step} - Action: {action_name} - Result: {result}\n")
            #self.last_step.observation = result
            self.last_step.observation = last_observation
            self.last_step.action = current_action
            print(f"Last observation {last_observation}")
            self.update_memory(self.last_step.observation)

        raise TimeoutError(f"Creator exceeded max steps ({self.max_steps})")
